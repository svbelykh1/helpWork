
- Каталоги
-- hier - Корневой unix    ???
-- etc  - Конфиги
-- bin  -  программы\команды операционной системы
-- sbin,libexec  - Административные, системные сервисы
-- etc/rc.d etc/init.d - скрипты
-- share - иконки обои шрифты документация
-- src  - исходные тесты
-- usr/bin usr/sbin -- программы которые пользовательские 
-- /home - домашний каталог
-- /var  от слова variable (логи библиотека) - изменяющиеся данные
-- /usr - установленнык пакеты программ
-- /boot — файлы загрузчика
-- /dev — файлы устройств
-- /srv файлы серверов и сервисов
/mnt — монтирование - Сюда сисадмины монтируют внешние либо дополнительные файловые системы Linux.

-Команды
-- cp -v - ключ -v от слова verbose - по подробней
-- df - diskFull  - показываает свободное место на диске
-- du - diskUsage - просмотр содержимого  
-- file/  - выведет тип файла
-- find /usr/share -name index.html - ищет файл index.html в каталоге 


- Чтение содержимого файла 
-- cat - открывает файл на чтение и выводит его на экран
-- more - для просмотра больших файлов(древняя) - выходит после пролистывание файла до конца 
-- less - усовершенствованная версия команды more понимает клавиши PageUp PageDown в отличие от more 
-- tail -n 5 - выводит хвосьт файла
-- head - выводит голову файла


- Редакторы
--nano - левый ALT+левый SHIFT+3 - появляется нумерация строк
ctl+O - сохранить
ctl+K - удалить ненужные строки 
	

- Фильтр
--grep svbelykh /etc/passwd - что(svbelykh) где искать(/etc/passwd)

-- grep -v '^#' /путь до файла - (регуляhка '^#' скажет грепу... покажи строки которые начинаются с #,а ключ -v скажет покажи строки которые НЕ начинаются с #)
-- '^#\|^$' -- Строки которые начинаюися с # либо строки которые начинаются и тут же заканыиваются.. т.е пустые
-- итог выведи строки которые не пустые и не начинаются с # -- grep -v '^#\|^$' /путь до файла

- Процессы
-- Много дядя рассказывал про shell bash и процессы в них ... но нихера не понятно было его объяснение 
-- Что удалось понять - это каждый процесс в линукс работает как минимум с двумя файлами к примеру оболочка bash раблтает с двумя файлами, это клавиатура он называл это файл номер 0
-- и экран файл номер 1 
--файл номер 0 - это stdin
--файл номер 1 - это  stdout ..Типа bash оболочка shell запирает символы с клавы и отдает на экран 
--ls -l /bin > ls.txt - перенаправит результат работы ls -l каталога /bin в файл ls.txt
--Есть еще один - это файл номер 2... эьто куда перенаправляются ошибки 
--Итог: 
--Команда просмотра места du -h  каталога /var выводит на экран .. по мимо результата  еще и ошибки связанные с правами .. дак вот нужно запомнить одну хуйню
-- команда вида ... du -h -s /var 1> du.txt 2>du_err.txt - просмотрит сколько места занято в каталоги /var и 
-- 1) результат(файла 1) который без ошибок и ворнингов перенапавит в файл du.txt
-- 2) результат(файла 2) с ошибками запишет в файл du_err.txt 
-- 3) Если мы не хотим ошибки никуда записывать то можно сказать 2>/dev/null - вот откуда этот ебаное понятие dev null 
-- еще пример с ыешт stdout .. ls /bin | wc -l (результат работы ls /bin(stdout) подаеься на вход wc -l (stdin) ) ... программа wc считает колво символов, строк, слов
-- find /etc 2>/dev/null | wc -l -- результат команды - вывод на экран количества файлов и файлов подкаталогов etc причем с перенаправление в дев нулл ошибок

КОДЫ ЗАВЕРШЕНИЯ ТРУЕ ФАЛЗЕ
-- ls /bin/ls >/dev/null && echo '/bin/ls exist!!!!' -- вывели bin/ls перенаправили вывод в дев нулл и если она выполнилась успешно то выведи на экран '/bin/ls exist!!!!'
-- СУКА еще одна шляпа которую мне рассказали.. и вспомнил что я не знал как ее понимать ))) вот эта запись... ls /bin/ls >/dev/null 2>/dev/null  ||  echo '/bin/ls exist!!!!' ====(равна)ls /bin/ls >/dev/null 2>&1 ||  echo '/bin/ls exist!!!!'
-- :> file1 - выражение назыввется дятел -  : - означает ничего и просто перезатрет файл 
Выражения в shell:
<<&&>> - когда предыдущая вернула труе
<<||>> -- когда предыдущяя вернула фалзе
<<;>> запуск команд не зависящих друг от друга
<<&>>-- ?????
-- hostnamectl - узнать имя сборки линукс
-- Ubuntu — это дистрибутив Linux, который существует в двух основных ветках:
 LTS (Long-Term Support) — версии с долгосрочной поддержкой, которые выпускаются раз в два года и получают обновления в течение пяти лет.
 «Обычные» версии — выпускаются каждые полгода и получают обновления в течение девяти месяцев.
//
 -- АНАлиз оборудования системы - dmesg И lshw
--  cat /proc/cpuinfo 
-- инфо о системе hostnamectl .. uname -a 
-- инфо о мудалях установленных - lsmod
-- ps-- список процессов текущего пользователя
-- ps ax - всех пользователей и системы
-- ps ax | grep ssh -- грепаем и видим что ssh рабоиает




--Модуль 5 насройка сети (192.168.0.201) - настройка сети производилась через нетплан, какая то инфа лежит тут cd /../netlan
-- про тестирование сети НИХУЯ не рассказал ВЯЧЕСЛАВ ЛОХТУРОВ(вроде так его звали)...
-- назвал команду ss -anp(какие порты прослушиваются в системе)

--модуль 6 Система безопасности Unix
-- показать всех пользователей зарегистрированных в системе getent passwd 
-- тожк самое можно сделать есть просто посмотерть файл cat /etc/passwd НО это локальная БД... и getent может показать 2000 пользователей...
     а в файле /etc/passwd может быть всего 20 пользователей.(нужно почитать про LDAP)
-- Короче нужно делать getent
-- Пароли хранятся в /etc/shadow пароль от пользователя 
-- Еще есть команда su -
-- Это ключевое различие между su и sudo. Su переключает вас в аккаунт root и требует пароля root.
     Sudo запускает с привилегиями root одну команду - она не переключает вас в аккаунт суперпользователя 
     и не требует отдельного пароля root.По умолчанию в ubuntu отключен пользователь root и при выполнении команды "su -" - ыв получите su: Authentication failure
-- пользователи которые могут подключиться по ssh(к командной оболочке) sudo cat /etc/passwd | grep "/bin/bash"
-- Добавление пользователя USER01  "useradd -m -s /bin/sh -c "ser bel,aud0,444,555" user01" 
-- (ключ -m домашний каталог в месте по умолчанию) (ключ -s с каким командным интерпритатором) (ключ с добавить информайию о пользователе ФИО телефон)
-- user01 passwd - установить пароль для пользователя 
-- На самом деле все эти инструкции useradd passwd редактируют файл /etc/passwd .. т/е можно было бы открыть этот файл и отредактировать его 
-- mkpasswd - Утилита просто выводит хэши паролей, поэтому в случае необходимости генерации хэшей паролей пользователей системы с помощью нее
     администратору придется добавлять их в файл /etc/shadow самостоятельно
-- ps ax - выведет все процессы с ID 
-- ps axu - выведет все процессы + EUID, где euid - имя пользователя (не знал - прикольно) буква E - охночает эффективный  т/е на данный момент
-- cat > test2.txt - команда cat читает с клавиатуры, а пишет в файл ... выйти или закончить запись - ctrl+D
-- ls -la ... выводит на экран -rw-rw-r-- 1 svbelykh svbelykh    14 дек 27 10:46  test2.txt (где svbelykh svbelykh - это пользователь и группа ) Для каждого пользователя создается и его группа
-- getent passwd - посмотреть всех пользователей
-- getent group - посмотерть группы
-- id - Чтобы вывести всю информацию о пользователе
-- id -G -  команда выводит идентификаторы групп
-- id -Gn - + имя групп 
-- Аналогинную информацию выводит команда groups, чтобы узнать список групп конкретного пользователянужно передать имя пользователя (groups ИМЯ_ПОЛЬЗОВАТЕЛЯ) 
-- umask покажет маску пользователя, если вы хотите изменить маску пользователя при создании файло нужно вспомнить про команду umask
-- ВОТ только тут я решил по разбираться с правами и НАЧАЛИ!!! (https://habr.com/ru/articles/469667/)
    - у каждого файла или каталога есть два владельца это пользователь и группа командой ls -l можно это увидеть
    - оболочка проверяет если вы являетесь вы владельцем файла или группы, если нет то вы получаете права для Other пользователей
    - find / -user svbelykh - так можно получить вписок всех файлов, которые принадлежат пользователю svbelykh
    - find / -group svbelykh - покажет у каких файлов владельцем является групп svbelykh( только нихуя не понятно .. выводит много всякой шляпы)
    - наконец то мы доблись до CHOWN - эта хуета изменяет владельца...чтобы поменять владельца файла или каталога и группу chown [владелец:группа] [каталог/файл]
    - пример - sudo chown svbelykh:svbelykh git
    - можно еще так(пример из статьи)- chown lisa.sales myfile устанавливает пользователя lisa владельцем файла myfile, а так же устанавливает
	 группу sales владельцем этого же файла.
    - Эффективная\первичная\ основная группа пользователя -  groups svbelykh ... чтобы ее изменить - newgrp [имя группы] 
	при этом пользователь должен входить в эту группу иначе запросит пароль
    - по chmod я уже что то знал на момент прочтения статьи, поэтому просто изложу свои мысли как есть :
	два режима - абсолютный и относительный ... в абсолютном три цифры к примеру 755 
	7 - для владельца, 5 - для группы, 5 для остальных 
	7 - получается из 4 - на чтение +  2 на запись + 1 на исполнение ... т.е все разрешено 
	5 - получается из чтение + исполнение 
	Сами 4 - чтение, 2- изменение , 1 - исполнение это результат по по битового сложения 
	-------------------------
	|   1   |  0   |   0    | - чтение R
	|-------|------|--------|
	|   0   |  1   |   0    | - запись\изменение W
	|-----------------------|
	|   0   |  0   |   1    | - исполнение X
	-------------------------
	Нужно помнить еще, так как для меня это было не очевидно.. что право Х(исполнение), а не R(чтение)-  дает права перехода в этот каталог
	Ну и относительный путь, о котором я узнал немного позже- выбираете для кого вы хотите добавить\удалить права (между пользователем (u), группой (g) и другими (o) )
	потом ввести добавить(+) или удалить(-)
	ну а потом что вы хотите добавить\удалить r-чтение  w- изменение  x - исполнение
	пример: chmod g+x [каталог] добавляет право на изменение\запись каталона\файла
	можно пропустить кому тогда право добавится всем пользователям к примеру .. chmod +x
	вот так перечислением, через запятую g+w,o-r somefile
	так же говорится про рекурсию, но в моих тестах это не получалось.. ну и времени не было, чтоб это проверять
	и оч интересное для меня )) при выполнении chmod -R o+rx /data мы предоставляем для всего data + всех файлов и каталогов в нем, права на чтение + исполнение..
	и помним что права x для каталога, нужны для того, чтобы перейти в него .. дак вот, если мы не хотим, чтобы у пользвателя не было права на исполннения файла, 
	а каталогам было(для перехода к примеру), нужно сказать chmod -R o+ rX /data
	Далее записывал про расширенные права, но я долбаеб, не сохранил.. попробую еще раз, то, что вспомню запишу
	SUID 
	    set user id - нужны для того, чтобы дать возможно исполнять файл от имени владельца
	    в абсолютном режиме дополняется еще одной цифрой (chmod 4755)
	    в относительном chmod u+s - увидим, что то типа -rwsrw---- 1 svbelykh svbelykh    29 янв 12 11:52  helloWorld.sh... s на позиции x - это и демонстирует
	    если (S) большая - это означает, что у самого владельца нет прав на исполнение.. исправить это можно про сто добавить ему права chmod u+x
	    
	SGID
	    ser group id - нужны для того, чтобы дать возможность запускать файлы с правами группы владельца
	    относительный - chmod g+s, абсолютный - chmod 2755 могу ошибаться по поводу абсолютного, перепроверит тот кто читает - я в сл. раз
	sticky bit
	    насколько помню не дает удалять файлы влательца 
	    относительный chmod +t, абсолютный 1755, так же могу ошибаться по поводу абсолютного
	Далее читал про umask .. понял так:
	маска доступа .. толи обратняя толи хз какая.. смысл в том, с помощью ее можно настроить права на создание файлов/каталогов по умолчанию
	если выполним команду umask, увидим такое 022 или 002 - это означает следующие...
	при создании файла максимальное для него(666) или каталога, максимальное для каталога 777, вычитанием маски из максимального будет определены права по 
	умолчанию. Пример маска 022, при создании файла - права будут 666 - 022 = 644(-rw-r--r--) при маске 002, права будут 664(-rw-rw-r--)
	для каталога тоже самое, только вычитать нужно из 777 а не 666 
	в рамках сессии задается umask 0002, для рута лежит нужно изменить значение в конфиге, который лежит тут /etc/login.defs
	Для пользователей всех6 нужно добавить в начале файла строку umask 002, так же можно по капаться в home/.profile конкретного пользователя
	Основное понятно -  едем дальше
	Была пауза в недели 3 - едем дальше

-СИГНАЛЫ ?????????????
-переменные окружения ENV - ????????????????????
